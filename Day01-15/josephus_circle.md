# 约瑟夫环问题 (Josephus circle)

## 问题描述

N个人围成一圈，从第一个开始报数，第M(M≤N)个将被杀掉，然后下一个人接着从1开始报数，最后剩下一个，其余人都将被杀掉。
最后的幸存者是第几个人？

## 问题分析

最容易想到的方法应该就是利用链表模拟整个过程，直到最后一个人停止，这个人就是我们要找到最后的幸存者，其对应的序号就是最终的答案。  
如果仔细去想一下这个问题，其实会发现，N个人时对应的最后的幸存者编号和N-1个人时对应的最后的幸存者编号时存在关系的，由此，我们可以得到一个递推式子，然后根据此递推式将原问题分解为相同的子问题从而求解。

### 链表模拟

pass

### 递归法---自顶向下思考(up to down)

为了方便理解我们就举一个例子：现在一共有9个人，第5个人将被杀掉，也就是N = 9,M = 5,求幸存者在原顺序中是第几个人？  
f(n)为当人数为n时，幸存者的在n个人中的次序  

`分析`：既然是自顶向下思考，那么我们就从f(9)开始一步一步向后递推，f(9)是幸存者在9个人中的次序。假设我们已知n = 8时幸存者一定是第k(1≤k≤8)个人，那么当第5个人被杀掉的时候，人数从n = 9变成了n = 8，也就是意味着我们现在从上一轮的第6个人开始求f(8),幸运的是，我们已经知道了当n = 8时，幸存者是第k个人了，因此求f(9)就变成了杀掉第5个人后从第6个人开始求f(8),简单地说就是从第6个人开始数，第k个人一定不会被杀，也就是所谓的f(9)。按照这样的逻辑，f(8)可以由f(7)得到，... ，f(2)可以由f(1)得到，而f(1) = 1(1个人的时候，肯定幸存者就是第一个人)。  
`递推关系`：f(n) = m+f(n-1)   当f(n)>n时，f(n) = (m+f(n-1))%n (另外一种求0...n-1个数剩下的最后一个数的题，不用分类，直接取余)  
`代码`：

```python
def get_survival_number(N, m):
    if N == 1:
        return 1
    temp = get_survival_number(N-1,m)+m
    if temp<=N:
        return temp
    else:
        return temp%N

# 求0...n-1个数排成一圈，从数字0开始，每次删除第m个数字（这题中m可以大于n），
# 求出剩下的最后一个数字
# -----来自leetcode中一道题（属于约瑟夫环）
def get_last_number(N, m):
    if N == 1:
        return 0
    return (get_survival_number(N-1,m)+m%N)%N

def main():
    print(get_survival_number(9,5))

if __name__ == "__main__":
    main()

```

`总结`：这种自顶向下思考的方式很重要，不仅在递归中起到作用，还在很多算法中都有用到，在分治法和动态规划中很重要。

